/// THIS CLASS HAS BEEN GENERATED BY CLAUDE.AI

package launcher;

import java.io.*;
import java.nio.file.Paths;

/**
 * TerminalLauncher - Creates a terminal window experience when JAR is double-clicked.
 *
 * This launcher:
 * 1. Detects if it's running in a terminal or from double-click
 * 2. If double-clicked, opens a new terminal window
 * 3. Runs the Spotify Server with full terminal output
 * 4. Keeps the terminal open after server stops
 */
public class TerminalLauncher {

    public static void main(String[] args) {
        try {
            // Check if we're running in a console/terminal
            if (System.console() == null && !isRunningInTerminal()) {
                // We were double-clicked! Launch in a new terminal window
                launchInTerminal();
            } else {
                // We're already in a terminal, run the server directly
                runServerWithTerminalExperience();
            }
        } catch (Exception e) {
            System.err.println("Failed to start server: " + e.getMessage());
            e.printStackTrace();

            // If we're in a GUI context, show a dialog
            if (System.console() == null) {
                try {
                    javax.swing.JOptionPane.showMessageDialog(null,
                            "Failed to start Spotify Server:\n" + e.getMessage(),
                            "Server Error",
                            javax.swing.JOptionPane.ERROR_MESSAGE);
                } catch (Exception ignored) {
                    // GUI not available, just exit
                }
            }
        }
    }

    /**
     * Launches the JAR in a new terminal window with proper title and behavior.
     */
    private static void launchInTerminal() throws IOException {
        String jarPath = getCurrentJarPath();
        String javaPath = System.getProperty("java.home") + File.separator + "bin" + File.separator + "java";

        ProcessBuilder pb = new ProcessBuilder();

        // Determine OS and create appropriate terminal command
        String os = System.getProperty("os.name").toLowerCase();

        if (os.contains("win")) {
            // Windows: Use cmd with custom title and keep window open
            pb.command("cmd", "/c", "start", "\"Spotify Server Console\"", "cmd", "/k",
                    "\"" + javaPath + "\" -jar \"" + jarPath + "\" --terminal");
        } else if (os.contains("mac")) {
            // macOS: Use Terminal.app
            pb.command("osascript", "-e",
                    "tell application \"Terminal\" to do script \"" +
                            javaPath + " -jar '" + jarPath + "' --terminal\"");
        } else {
            // Linux: Try different terminal emulators
            String[] terminals = {"gnome-terminal", "konsole", "xterm", "terminator"};
            String terminal = null;

            for (String term : terminals) {
                if (isCommandAvailable(term)) {
                    terminal = term;
                    break;
                }
            }

            if (terminal != null) {
                if (terminal.equals("gnome-terminal")) {
                    pb.command(terminal, "--title=Spotify Server Console", "--",
                            javaPath, "-jar", jarPath, "--terminal");
                } else if (terminal.equals("konsole")) {
                    pb.command(terminal, "--title", "Spotify Server Console", "-e",
                            javaPath, "-jar", jarPath, "--terminal");
                } else {
                    pb.command(terminal, "-title", "Spotify Server Console", "-e",
                            javaPath, "-jar", jarPath, "--terminal");
                }
            } else {
                // Fallback: run in background and show message
                System.out.println("No terminal emulator found. Running server in background...");
                runServerWithTerminalExperience();
                return;
            }
        }

        pb.start();
    }

    /**
     * Runs the server with a full terminal experience - colors, formatting, interactive feel.
     */
    private static void runServerWithTerminalExperience() {
        // Set up nice terminal experience
        System.setProperty("java.awt.headless", "false"); // Allow GUI if needed

        // Print fancy startup banner
        printStartupBanner();

        // Check ports before starting
        if (!checkAndCleanPorts()) {
            System.out.println("âŒ Cannot start server - ports are in use");
            System.out.println("Press Enter to exit...");
            try {
                System.in.read();
            } catch (IOException ignored) {}
            return;
        }

        // Set up shutdown hook for clean exit message
        Runtime.getRuntime().addShutdownHook(new Thread(() -> {
            System.out.println("\n" + "=".repeat(60));
            System.out.println("ðŸ›‘ Spotify Server Shutdown");
            System.out.println("=".repeat(60));
            System.out.println("Thank you for using Spotify Server!");

            // Keep window open on Windows
            if (System.getProperty("os.name").toLowerCase().contains("win")) {
                System.out.println("\nPress any key to close this window...");
                try {
                    System.in.read();
                } catch (IOException ignored) {}
            }
        }));

        try {
            // Start the actual Spotify Server
            System.out.println("ðŸš€ Starting Spotify Server...\n");
            spotifyServer.SpotifySocketServer.main(new String[0]);

        } catch (Exception e) {
            System.err.println("\nâŒ Server failed to start: " + e.getMessage());
            e.printStackTrace();

            System.out.println("\n" + "=".repeat(60));
            System.out.println("Press Enter to exit...");
            try {
                System.in.read();
            } catch (IOException ignored) {}
        }
    }

    /**
     * Prints a fancy startup banner like IntelliJ console.
     */
    private static void printStartupBanner() {
        System.out.println("â•”" + "â•".repeat(58) + "â•—");
        System.out.println("â•‘" + centerText("ðŸŽµ SPOTIFY SERVER CONSOLE ðŸŽµ", 58) + "â•‘");
        System.out.println("â•‘" + centerText("", 58) + "â•‘");
        System.out.println("â•‘" + centerText("Command Port: 45000 | Streaming Port: 45001", 58) + "â•‘");
        System.out.println("â•‘" + centerText("Press Ctrl+C to stop the server", 58) + "â•‘");
        System.out.println("â•š" + "â•".repeat(58) + "â•");
        System.out.println();

        // Add some system info like IntelliJ does
        System.out.println("Java Version: " + System.getProperty("java.version"));
        System.out.println("Java Home: " + System.getProperty("java.home"));
        System.out.println("Working Directory: " + System.getProperty("user.dir"));
        System.out.println("OS: " + System.getProperty("os.name") + " " + System.getProperty("os.version"));
        System.out.println("User: " + System.getProperty("user.name"));
        System.out.println();
        System.out.println("=".repeat(60));
    }

    /**
     * Centers text within a given width.
     */
    private static String centerText(String text, int width) {
        if (text.length() >= width) return text;
        int padding = (width - text.length()) / 2;
        return " ".repeat(padding) + text + " ".repeat(width - text.length() - padding);
    }

    /**
     * Gets the path of the currently running JAR file.
     */
    private static String getCurrentJarPath() {
        try {
            return new File(TerminalLauncher.class.getProtectionDomain()
                    .getCodeSource().getLocation().toURI()).getAbsolutePath();
        } catch (Exception e) {
            // Fallback
            return "spotify-server.jar";
        }
    }

    /**
     * Checks if we're running in a real terminal (not just headless).
     */
    private static boolean isRunningInTerminal() {
        // Check for terminal indicators
        return System.getenv("TERM") != null ||
                System.getenv("SSH_TTY") != null ||
                "true".equals(System.getProperty("java.awt.headless"));
    }

    /**
     * Checks if a command is available in the system PATH.
     */
    private static boolean isCommandAvailable(String command) {
        try {
            Process process = new ProcessBuilder("which", command).start();
            return process.waitFor() == 0;
        } catch (Exception e) {
            return false;
        }
    }

    /**
     * Checks if ports 45000 and 45001 are available, and offers to clean them if needed.
     */
    private static boolean checkAndCleanPorts() {
        System.out.println("ðŸ” Checking server ports...");

        boolean port45000Free = isPortAvailable(45000);
        boolean port45001Free = isPortAvailable(45001);

        if (port45000Free && port45001Free) {
            System.out.println("âœ… Both ports 45000 and 45001 are available");
            return true;
        }

        System.out.println("\nâš ï¸  Port conflict detected:");
        if (!port45000Free) {
            System.out.println("   - Port 45000 (Command) is in use");
        }
        if (!port45001Free) {
            System.out.println("   - Port 45001 (Streaming) is in use");
        }

        System.out.println("\nThis usually means another Spotify Server is running.");
        System.out.print("Would you like to automatically kill processes using these ports? (y/n): ");

        try {
            int input = System.in.read();
            if (input == 'y' || input == 'Y') {
                return killPortProcesses();
            } else {
                System.out.println("\nðŸ’¡ To manually fix this:");
                System.out.println("   1. Close any other Spotify Server instances");
                System.out.println("   2. Or run: taskkill /f /im java.exe");
                System.out.println("   3. Then restart this server");
                return false;
            }
        } catch (IOException e) {
            System.out.println("Error reading input, assuming 'no'");
            return false;
        }
    }

    /**
     * Checks if a specific port is available.
     */
    private static boolean isPortAvailable(int port) {
        try (java.net.ServerSocket serverSocket = new java.net.ServerSocket(port)) {
            return true;
        } catch (IOException e) {
            return false;
        }
    }

    /**
     * Attempts to kill processes using ports 45000 and 45001.
     */
    private static boolean killPortProcesses() {
        System.out.println("\nðŸ”§ Attempting to free ports...");

        try {
            String os = System.getProperty("os.name").toLowerCase();

            if (os.contains("win")) {
                // Windows: Use netstat and taskkill
                killPortProcessesWindows(45000);
                killPortProcessesWindows(45001);
            } else {
                // Unix-like: Use lsof and kill
                killPortProcessesUnix(45000);
                killPortProcessesUnix(45001);
            }

            // Wait a moment for processes to die
            Thread.sleep(2000);

            // Check if ports are now free
            boolean port45000Free = isPortAvailable(45000);
            boolean port45001Free = isPortAvailable(45001);

            if (port45000Free && port45001Free) {
                System.out.println("âœ… Ports successfully freed!");
                return true;
            } else {
                System.out.println("âŒ Some ports are still in use. You may need to manually close applications.");
                return false;
            }

        } catch (Exception e) {
            System.out.println("âŒ Error attempting to free ports: " + e.getMessage());
            return false;
        }
    }

    /**
     * Kills processes using a specific port on Windows.
     */
    private static void killPortProcessesWindows(int port) {
        try {
            // Find processes using the port
            Process netstatProcess = new ProcessBuilder("netstat", "-ano").start();
            BufferedReader reader = new BufferedReader(new InputStreamReader(netstatProcess.getInputStream()));

            String line;
            while ((line = reader.readLine()) != null) {
                if (line.contains(":" + port + " ")) {
                    String[] parts = line.trim().split("\\s+");
                    if (parts.length >= 5) {
                        String pid = parts[4];
                        try {
                            // Kill the process
                            new ProcessBuilder("taskkill", "/pid", pid, "/f").start().waitFor();
                            System.out.println("   Killed process " + pid + " using port " + port);
                        } catch (Exception e) {
                            System.out.println("   Failed to kill process " + pid);
                        }
                    }
                }
            }
            reader.close();

        } catch (Exception e) {
            System.out.println("   Error checking port " + port + ": " + e.getMessage());
        }
    }

    /**
     * Kills processes using a specific port on Unix-like systems.
     */
    private static void killPortProcessesUnix(int port) {
        try {
            // Find processes using the port
            Process lsofProcess = new ProcessBuilder("lsof", "-ti:" + port).start();
            BufferedReader reader = new BufferedReader(new InputStreamReader(lsofProcess.getInputStream()));

            String pid;
            while ((pid = reader.readLine()) != null) {
                try {
                    // Kill the process
                    new ProcessBuilder("kill", "-9", pid).start().waitFor();
                    System.out.println("   Killed process " + pid + " using port " + port);
                } catch (Exception e) {
                    System.out.println("   Failed to kill process " + pid);
                }
            }
            reader.close();

        } catch (Exception e) {
            System.out.println("   Error checking port " + port + ": " + e.getMessage());
        }
    }
}